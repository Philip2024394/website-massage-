<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Therapist Card Duplicate Checker</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .status-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            border-left: 4px solid #007bff;
        }
        
        .status-success { border-left-color: #28a745; background: #d4edda; }
        .status-warning { border-left-color: #ffc107; background: #fff3cd; }
        .status-error { border-left-color: #dc3545; background: #f8d7da; }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            margin: 10px;
            transition: all 0.3s;
        }
        
        button:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }
        
        .button-danger {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }
        
        .button-success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }
        
        #output {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #ddd;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .duplicate-card {
            background: #fff5f5;
            border: 2px solid #feb2b2;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .clean-card {
            background: #f0fff4;
            border: 2px solid #9ae6b4;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ” Therapist Card Duplicate Checker</h1>
        
        <div class="status-card">
            <h3>ğŸ¯ Purpose</h3>
            <p><strong>Check for multiple therapist cards</strong> that could cause data fetching issues</p>
            <p><strong>Enforce one-card-per-therapist policy</strong> for better performance</p>
            <p><strong>Clean up duplicate entries</strong> to prevent confusion</p>
        </div>

        <div class="grid">
            <div class="status-card">
                <h3>ğŸ” Detection Tools</h3>
                <button onclick="checkForDuplicates()">ğŸ” Check for Duplicates</button>
                <button onclick="analyzeTherapistData()">ğŸ“Š Analyze Therapist Data</button>
                <button onclick="validateOneCardPolicy()">âœ… Validate One-Card Policy</button>
            </div>
            
            <div class="status-card">
                <h3>ğŸ› ï¸ Cleanup Tools</h3>
                <button onclick="removeDuplicates()" class="button-danger">ğŸ—‘ï¸ Remove Duplicates</button>
                <button onclick="mergeProfiles()">ğŸ”— Merge Profiles</button>
                <button onclick="resetTherapistData()" class="button-danger">ğŸ”„ Reset All Data</button>
            </div>
            
            <div class="status-card">
                <h3>ğŸ“‹ Diagnostic Tools</h3>
                <button onclick="generateDuplicateReport()">ğŸ“ Generate Report</button>
                <button onclick="testDataFetchPerformance()">âš¡ Test Fetch Performance</button>
                <button onclick="verifyAppwriteSync()">â˜ï¸ Verify Appwrite Sync</button>
            </div>
            
            <div class="status-card">
                <h3>ğŸ¯ Quick Fixes</h3>
                <button onclick="enforceOneCardPolicy()" class="button-success">ğŸ›¡ï¸ Enforce One Card Policy</button>
                <button onclick="optimizeForFetching()">ğŸš€ Optimize for Fetching</button>
                <button onclick="runFullCleanup()" class="button-success">ğŸ§¹ Full Cleanup</button>
            </div>
        </div>

        <div id="output"></div>
    </div>

    <script>
        function log(message, type = 'info') {
            const output = document.getElementById('output');
            const timestamp = new Date().toLocaleTimeString();
            const icon = type === 'error' ? 'âŒ' : type === 'success' ? 'âœ…' : type === 'warning' ? 'âš ï¸' : 'â„¹ï¸';
            output.textContent += `[${timestamp}] ${icon} ${message}\n`;
            output.scrollTop = output.scrollHeight;
        }

        function clearOutput() {
            document.getElementById('output').textContent = '';
        }

        function checkForDuplicates() {
            clearOutput();
            log('ğŸ” Checking for Duplicate Therapist Cards...', 'info');
            
            const therapists = JSON.parse(localStorage.getItem('app_therapists') || '[]');
            
            if (therapists.length === 0) {
                log('âŒ No therapist data found', 'error');
                return;
            }
            
            log(`Total therapist entries: ${therapists.length}`, 'info');
            
            // Group by different potential duplicate indicators
            const byName = {};
            const byEmail = {};
            const byWhatsApp = {};
            const byUserId = {};
            
            therapists.forEach((therapist, index) => {
                const name = therapist.name?.toLowerCase().trim() || `unnamed_${index}`;
                const email = therapist.email?.toLowerCase() || `no_email_${index}`;
                const whatsapp = therapist.whatsappNumber || `no_whatsapp_${index}`;
                const userId = therapist.userId || therapist.$id || `no_id_${index}`;
                
                // Group by name
                if (!byName[name]) byName[name] = [];
                byName[name].push({...therapist, index});
                
                // Group by email
                if (!byEmail[email]) byEmail[email] = [];
                byEmail[email].push({...therapist, index});
                
                // Group by whatsapp
                if (!byWhatsApp[whatsapp]) byWhatsApp[whatsapp] = [];
                byWhatsApp[whatsapp].push({...therapist, index});
                
                // Group by user ID
                if (!byUserId[userId]) byUserId[userId] = [];
                byUserId[userId].push({...therapist, index});
            });
            
            // Find duplicates
            let duplicatesFound = false;
            
            // Check name duplicates
            log('\nğŸ“‹ Checking Name Duplicates:', 'info');
            Object.entries(byName).forEach(([name, profiles]) => {
                if (profiles.length > 1 && name !== 'unnamed' && !name.includes('unnamed_')) {
                    log(`âš ï¸ Name "${name}": ${profiles.length} profiles`, 'warning');
                    profiles.forEach(p => log(`   - ID: ${p.$id} (Live: ${p.isLive ? 'Yes' : 'No'})`, 'info'));
                    duplicatesFound = true;
                }
            });
            
            // Check email duplicates
            log('\nğŸ“§ Checking Email Duplicates:', 'info');
            Object.entries(byEmail).forEach(([email, profiles]) => {
                if (profiles.length > 1 && !email.includes('no_email_')) {
                    log(`âš ï¸ Email "${email}": ${profiles.length} profiles`, 'warning');
                    profiles.forEach(p => log(`   - Name: ${p.name} ID: ${p.$id}`, 'info'));
                    duplicatesFound = true;
                }
            });
            
            // Check WhatsApp duplicates
            log('\nğŸ“± Checking WhatsApp Duplicates:', 'info');
            Object.entries(byWhatsApp).forEach(([whatsapp, profiles]) => {
                if (profiles.length > 1 && !whatsapp.includes('no_whatsapp_')) {
                    log(`âš ï¸ WhatsApp "${whatsapp}": ${profiles.length} profiles`, 'warning');
                    profiles.forEach(p => log(`   - Name: ${p.name} ID: ${p.$id}`, 'info'));
                    duplicatesFound = true;
                }
            });
            
            // Check User ID duplicates (most critical)
            log('\nğŸ†” Checking User ID Duplicates:', 'info');
            Object.entries(byUserId).forEach(([userId, profiles]) => {
                if (profiles.length > 1 && !userId.includes('no_id_')) {
                    log(`ğŸš¨ CRITICAL: User ID "${userId}": ${profiles.length} profiles`, 'error');
                    profiles.forEach(p => log(`   - Name: ${p.name} Live: ${p.isLive}`, 'error'));
                    duplicatesFound = true;
                }
            });
            
            if (!duplicatesFound) {
                log('\nâœ… No duplicates found - One card policy is working!', 'success');
                log('All therapists have unique identifiers', 'success');
            } else {
                log('\nğŸš¨ Duplicates detected - This can cause data fetching issues!', 'error');
                log('Recommended: Run cleanup tools to fix duplicates', 'warning');
            }
            
            return { duplicatesFound, totalCount: therapists.length };
        }

        function analyzeTherapistData() {
            clearOutput();
            log('ğŸ“Š Analyzing Therapist Data Structure...', 'info');
            
            const therapists = JSON.parse(localStorage.getItem('app_therapists') || '[]');
            
            if (therapists.length === 0) {
                log('âŒ No therapist data to analyze', 'error');
                return;
            }
            
            log(`Total therapists: ${therapists.length}`, 'info');
            
            // Analyze data completeness
            let completeProfiles = 0;
            let liveProfiles = 0;
            let profilesWithPricing = 0;
            let profilesWithImages = 0;
            
            const issues = [];
            
            therapists.forEach((therapist, index) => {
                const hasName = !!therapist.name;
                const hasDescription = !!therapist.description;
                const hasLocation = !!therapist.location;
                const hasWhatsApp = !!therapist.whatsappNumber;
                const hasPricing = !!therapist.pricing;
                const hasProfilePicture = !!therapist.profilePicture;
                const isLive = therapist.isLive === true;
                
                if (hasName && hasDescription && hasLocation && hasWhatsApp) {
                    completeProfiles++;
                }
                
                if (isLive) {
                    liveProfiles++;
                }
                
                if (hasPricing) {
                    try {
                        const pricing = JSON.parse(therapist.pricing);
                        if (pricing["60"] > 0 || pricing["90"] > 0 || pricing["120"] > 0) {
                            profilesWithPricing++;
                        }
                    } catch (e) {
                        issues.push(`Therapist ${therapist.name}: Invalid pricing JSON`);
                    }
                }
                
                if (hasProfilePicture) {
                    profilesWithImages++;
                }
                
                // Check for potential data issues
                if (!hasName) {
                    issues.push(`Therapist ${index + 1}: Missing name`);
                }
                
                if (hasName && !therapist.$id) {
                    issues.push(`Therapist ${therapist.name}: Missing $id`);
                }
                
                if (hasName && !therapist.userId) {
                    issues.push(`Therapist ${therapist.name}: Missing userId`);
                }
            });
            
            log('\nğŸ“ˆ Data Quality Analysis:', 'info');
            log(`Complete profiles: ${completeProfiles}/${therapists.length} (${Math.round(completeProfiles/therapists.length*100)}%)`, 'info');
            log(`Live profiles: ${liveProfiles}/${therapists.length} (${Math.round(liveProfiles/therapists.length*100)}%)`, 'info');
            log(`Valid pricing: ${profilesWithPricing}/${therapists.length} (${Math.round(profilesWithPricing/therapists.length*100)}%)`, 'info');
            log(`Profile pictures: ${profilesWithImages}/${therapists.length} (${Math.round(profilesWithImages/therapists.length*100)}%)`, 'info');
            
            if (issues.length > 0) {
                log('\nâš ï¸ Data Issues Found:', 'warning');
                issues.forEach(issue => log(`   - ${issue}`, 'warning'));
            } else {
                log('\nâœ… No data quality issues found', 'success');
            }
            
            // Performance impact analysis
            log('\nâš¡ Performance Impact:', 'info');
            if (therapists.length > 50) {
                log('âš ï¸ Large dataset - may affect fetching performance', 'warning');
            } else if (therapists.length > 20) {
                log('ğŸ“Š Medium dataset - performance should be good', 'info');
            } else {
                log('âœ… Small dataset - optimal performance', 'success');
            }
        }

        function validateOneCardPolicy() {
            clearOutput();
            log('âœ… Validating One-Card Policy...', 'info');
            
            const therapists = JSON.parse(localStorage.getItem('app_therapists') || '[]');
            const currentUser = JSON.parse(localStorage.getItem('app_current_user') || 'null');
            const therapistId = localStorage.getItem('app_therapist_id');
            
            if (!currentUser || !therapistId) {
                log('âš ï¸ Cannot validate - no logged in therapist', 'warning');
                log('Login as a therapist to test the policy', 'info');
                return;
            }
            
            log(`Checking policy for therapist ID: ${therapistId}`, 'info');
            log(`Logged in as: ${currentUser.name} (${currentUser.email})`, 'info');
            
            // Find all profiles for this therapist
            const myProfiles = therapists.filter(t => 
                t.$id === therapistId || 
                t.userId === therapistId || 
                t.userId === currentUser.$id ||
                t.email === currentUser.email
            );
            
            log(`\nğŸ“Š Policy Validation Results:`, 'info');
            log(`Profiles found for this therapist: ${myProfiles.length}`, 'info');
            
            if (myProfiles.length === 0) {
                log('âœ… No profile exists yet - ready to create first card', 'success');
                log('Policy status: COMPLIANT (0/1 cards)', 'success');
            } else if (myProfiles.length === 1) {
                log('âœ… Exactly one profile found - policy compliant!', 'success');
                log(`Profile: ${myProfiles[0].name} (Live: ${myProfiles[0].isLive ? 'Yes' : 'No'})`, 'info');
                log('Policy status: COMPLIANT (1/1 cards)', 'success');
            } else {
                log('ğŸš¨ POLICY VIOLATION: Multiple profiles found!', 'error');
                myProfiles.forEach((profile, index) => {
                    log(`${index + 1}. Name: ${profile.name} ID: ${profile.$id} Live: ${profile.isLive}`, 'error');
                });
                log(`Policy status: VIOLATION (${myProfiles.length}/1 cards)`, 'error');
                log('This could cause data fetching confusion!', 'warning');
            }
            
            return { 
                compliant: myProfiles.length <= 1, 
                profileCount: myProfiles.length,
                profiles: myProfiles 
            };
        }

        function removeDuplicates() {
            clearOutput();
            log('ğŸ—‘ï¸ Removing Duplicate Therapist Cards...', 'warning');
            
            let therapists = JSON.parse(localStorage.getItem('app_therapists') || '[]');
            const originalCount = therapists.length;
            
            if (therapists.length === 0) {
                log('âŒ No therapist data to process', 'error');
                return;
            }
            
            log(`Original count: ${originalCount}`, 'info');
            
            // Group by user ID (most reliable identifier)
            const grouped = {};
            therapists.forEach(therapist => {
                const key = therapist.userId || therapist.$id || therapist.email || 'unknown';
                if (!grouped[key]) grouped[key] = [];
                grouped[key].push(therapist);
            });
            
            let removedCount = 0;
            const cleanedTherapists = [];
            
            Object.entries(grouped).forEach(([key, profiles]) => {
                if (profiles.length === 1) {
                    // No duplicates, keep as is
                    cleanedTherapists.push(profiles[0]);
                } else if (profiles.length > 1) {
                    log(`ğŸ” Processing ${profiles.length} duplicates for key: ${key}`, 'warning');
                    
                    // Keep the best profile (most complete data, is live, most recent)
                    const bestProfile = profiles.reduce((best, current) => {
                        const bestScore = calculateProfileScore(best);
                        const currentScore = calculateProfileScore(current);
                        return currentScore > bestScore ? current : best;
                    });
                    
                    cleanedTherapists.push(bestProfile);
                    removedCount += profiles.length - 1;
                    
                    log(`   Kept: ${bestProfile.name} (Score: ${calculateProfileScore(bestProfile)})`, 'success');
                    log(`   Removed: ${profiles.length - 1} duplicates`, 'info');
                }
            });
            
            // Update storage
            localStorage.setItem('app_therapists', JSON.stringify(cleanedTherapists));
            
            log(`\nâœ… Cleanup Complete!`, 'success');
            log(`Original: ${originalCount} therapists`, 'info');
            log(`Cleaned: ${cleanedTherapists.length} therapists`, 'info');
            log(`Removed: ${removedCount} duplicates`, 'success');
            
            if (removedCount > 0) {
                log('\nğŸ¯ Benefits:', 'info');
                log('â€¢ Faster data fetching', 'info');
                log('â€¢ No duplicate cards on home page', 'info');
                log('â€¢ Cleaner dashboard experience', 'info');
                log('â€¢ Better Appwrite sync performance', 'info');
            }
        }

        function calculateProfileScore(profile) {
            let score = 0;
            
            // Basic completeness (40 points max)
            if (profile.name) score += 10;
            if (profile.description) score += 10;
            if (profile.location) score += 5;
            if (profile.whatsappNumber) score += 5;
            if (profile.profilePicture) score += 10;
            
            // Pricing (20 points max)
            if (profile.pricing) {
                try {
                    const pricing = JSON.parse(profile.pricing);
                    if (pricing["60"] > 0) score += 5;
                    if (pricing["90"] > 0) score += 5;
                    if (pricing["120"] > 0) score += 5;
                    score += 5; // For having valid pricing structure
                } catch (e) {
                    // Invalid pricing, no points
                }
            }
            
            // Status (20 points max)
            if (profile.isLive) score += 15;
            if (profile.status === 'online') score += 5;
            
            // Additional features (20 points max)
            if (profile.massageTypes && profile.massageTypes.length > 0) score += 5;
            if (profile.languages && profile.languages.length > 0) score += 5;
            if (profile.yearsOfExperience > 0) score += 5;
            if (profile.$createdAt) score += 5;
            
            return score;
        }

        function mergeProfiles() {
            clearOutput();
            log('ğŸ”— Merging Duplicate Profiles...', 'info');
            
            let therapists = JSON.parse(localStorage.getItem('app_therapists') || '[]');
            
            // Group duplicates
            const grouped = {};
            therapists.forEach(therapist => {
                const key = therapist.userId || therapist.$id || therapist.email || 'unknown';
                if (!grouped[key]) grouped[key] = [];
                grouped[key].push(therapist);
            });
            
            const mergedTherapists = [];
            let mergeCount = 0;
            
            Object.entries(grouped).forEach(([key, profiles]) => {
                if (profiles.length === 1) {
                    mergedTherapists.push(profiles[0]);
                } else {
                    // Merge multiple profiles into one comprehensive profile
                    const merged = mergeTherapistProfiles(profiles);
                    mergedTherapists.push(merged);
                    mergeCount++;
                    
                    log(`ğŸ”— Merged ${profiles.length} profiles for: ${merged.name}`, 'success');
                }
            });
            
            localStorage.setItem('app_therapists', JSON.stringify(mergedTherapists));
            
            log(`\nâœ… Merge Complete!`, 'success');
            log(`Merged ${mergeCount} sets of duplicate profiles`, 'info');
            log(`Final count: ${mergedTherapists.length} unique therapists`, 'success');
        }

        function mergeTherapistProfiles(profiles) {
            // Start with the most complete profile as base
            const baseProfile = profiles.reduce((best, current) => {
                return calculateProfileScore(current) > calculateProfileScore(best) ? current : best;
            });
            
            const merged = { ...baseProfile };
            
            // Merge data from other profiles (take best non-empty values)
            profiles.forEach(profile => {
                Object.keys(profile).forEach(key => {
                    if (!merged[key] && profile[key]) {
                        merged[key] = profile[key];
                    } else if (key === 'description' && profile[key] && profile[key].length > (merged[key]?.length || 0)) {
                        merged[key] = profile[key];
                    } else if (key === 'massageTypes' && profile[key] && profile[key].length > 0) {
                        merged[key] = [...new Set([...(merged[key] || []), ...profile[key]])];
                    } else if (key === 'languages' && profile[key] && profile[key].length > 0) {
                        merged[key] = [...new Set([...(merged[key] || []), ...profile[key]])];
                    }
                });
            });
            
            // Ensure isLive is true if any profile was live
            merged.isLive = profiles.some(p => p.isLive === true);
            
            return merged;
        }

        function enforceOneCardPolicy() {
            clearOutput();
            log('ğŸ›¡ï¸ Enforcing One Card Policy...', 'success');
            
            const currentUser = JSON.parse(localStorage.getItem('app_current_user') || 'null');
            const therapistId = localStorage.getItem('app_therapist_id');
            
            if (!currentUser || !therapistId) {
                log('âš ï¸ Cannot enforce policy - no logged in therapist', 'warning');
                return;
            }
            
            let therapists = JSON.parse(localStorage.getItem('app_therapists') || '[]');
            
            // Find all profiles for current user
            const myProfiles = therapists.filter(t => 
                t.$id === therapistId || 
                t.userId === therapistId || 
                t.userId === currentUser.$id ||
                t.email === currentUser.email
            );
            
            log(`Found ${myProfiles.length} profiles for current user`, 'info');
            
            if (myProfiles.length <= 1) {
                log('âœ… Policy already compliant - no action needed', 'success');
                return;
            }
            
            // Keep the best profile, remove others
            const bestProfile = myProfiles.reduce((best, current) => {
                return calculateProfileScore(current) > calculateProfileScore(best) ? current : best;
            });
            
            // Remove other profiles for this user
            therapists = therapists.filter(t => {
                const isMyProfile = t.$id === therapistId || 
                                  t.userId === therapistId || 
                                  t.userId === currentUser.$id ||
                                  t.email === currentUser.email;
                
                if (isMyProfile && t !== bestProfile) {
                    log(`Removing profile: ${t.name} (ID: ${t.$id})`, 'warning');
                    return false;
                }
                return true;
            });
            
            // Add the best profile back if it was filtered out
            if (!therapists.find(t => t.$id === bestProfile.$id)) {
                therapists.push(bestProfile);
            }
            
            localStorage.setItem('app_therapists', JSON.stringify(therapists));
            
            log(`âœ… Policy enforced! Kept best profile: ${bestProfile.name}`, 'success');
            log(`Removed ${myProfiles.length - 1} duplicate profiles`, 'info');
        }

        function testDataFetchPerformance() {
            clearOutput();
            log('âš¡ Testing Data Fetch Performance...', 'info');
            
            const therapists = JSON.parse(localStorage.getItem('app_therapists') || '[]');
            
            if (therapists.length === 0) {
                log('âŒ No data to test performance with', 'error');
                return;
            }
            
            const startTime = performance.now();
            
            // Simulate common operations
            const liveTherapists = therapists.filter(t => t.isLive === true);
            const therapistsWithPricing = therapists.filter(t => {
                try {
                    if (!t.pricing) return false;
                    const pricing = JSON.parse(t.pricing);
                    return pricing["60"] > 0 || pricing["90"] > 0 || pricing["120"] > 0;
                } catch {
                    return false;
                }
            });
            
            // Simulate finding specific therapist
            const currentUser = JSON.parse(localStorage.getItem('app_current_user') || 'null');
            const therapistId = localStorage.getItem('app_therapist_id');
            const myProfile = therapists.find(t => t.$id === therapistId);
            
            const endTime = performance.now();
            const duration = endTime - startTime;
            
            log(`Performance Test Results:`, 'info');
            log(`Dataset size: ${therapists.length} therapists`, 'info');
            log(`Processing time: ${duration.toFixed(2)}ms`, 'info');
            
            if (duration < 10) {
                log(`âœ… Excellent performance (< 10ms)`, 'success');
            } else if (duration < 50) {
                log(`âœ… Good performance (< 50ms)`, 'success');
            } else if (duration < 100) {
                log(`âš ï¸ Fair performance (< 100ms)`, 'warning');
            } else {
                log(`âŒ Poor performance (> 100ms)`, 'error');
                log(`Consider reducing dataset size or removing duplicates`, 'warning');
            }
            
            log(`\nOperations tested:`, 'info');
            log(`- Live therapists: ${liveTherapists.length} found`, 'info');
            log(`- Valid pricing: ${therapistsWithPricing.length} found`, 'info');
            log(`- Current profile: ${myProfile ? 'Found' : 'Not found'}`, 'info');
            
            // Test for potential bottlenecks
            const duplicateEmails = new Set();
            const duplicateWhatsApp = new Set();
            let potentialDuplicates = 0;
            
            therapists.forEach(t => {
                if (t.email && duplicateEmails.has(t.email)) potentialDuplicates++;
                else if (t.email) duplicateEmails.add(t.email);
                
                if (t.whatsappNumber && duplicateWhatsApp.has(t.whatsappNumber)) potentialDuplicates++;
                else if (t.whatsappNumber) duplicateWhatsApp.add(t.whatsappNumber);
            });
            
            if (potentialDuplicates > 0) {
                log(`âš ï¸ ${potentialDuplicates} potential duplicates detected`, 'warning');
                log(`This could slow down data operations`, 'warning');
            }
        }

        function verifyAppwriteSync() {
            clearOutput();
            log('â˜ï¸ Verifying Appwrite Sync Readiness...', 'info');
            
            const therapists = JSON.parse(localStorage.getItem('app_therapists') || '[]');
            
            if (therapists.length === 0) {
                log('âŒ No local data to sync', 'error');
                return;
            }
            
            log('Checking data quality for Appwrite sync...', 'info');
            
            let readyForSync = 0;
            let needsCleanup = 0;
            const issues = [];
            
            therapists.forEach((therapist, index) => {
                const hasRequiredFields = therapist.$id && therapist.name;
                const hasValidStructure = typeof therapist === 'object';
                let hasValidPricing = false;
                
                if (therapist.pricing) {
                    try {
                        JSON.parse(therapist.pricing);
                        hasValidPricing = true;
                    } catch {
                        issues.push(`${therapist.name || 'Unnamed'}: Invalid pricing JSON`);
                    }
                }
                
                if (hasRequiredFields && hasValidStructure && (hasValidPricing || !therapist.pricing)) {
                    readyForSync++;
                } else {
                    needsCleanup++;
                    if (!therapist.$id) issues.push(`${therapist.name || 'Unnamed'}: Missing $id`);
                    if (!therapist.name) issues.push(`Profile ${index}: Missing name`);
                }
            });
            
            log(`\nSync Readiness Report:`, 'info');
            log(`Ready for sync: ${readyForSync}/${therapists.length} (${Math.round(readyForSync/therapists.length*100)}%)`, readyForSync === therapists.length ? 'success' : 'warning');
            log(`Need cleanup: ${needsCleanup}/${therapists.length}`, needsCleanup === 0 ? 'success' : 'warning');
            
            if (issues.length > 0) {
                log('\nIssues to fix before sync:', 'warning');
                issues.forEach(issue => log(`â€¢ ${issue}`, 'warning'));
            } else {
                log('\nâœ… All data ready for Appwrite sync!', 'success');
            }
            
            // Check for sync conflicts (duplicates)
            const uniqueIds = new Set();
            let duplicateIds = 0;
            
            therapists.forEach(t => {
                if (uniqueIds.has(t.$id)) {
                    duplicateIds++;
                } else {
                    uniqueIds.add(t.$id);
                }
            });
            
            if (duplicateIds > 0) {
                log(`âš ï¸ ${duplicateIds} duplicate IDs found - will cause sync conflicts!`, 'error');
            } else {
                log('âœ… No duplicate IDs - sync will be clean', 'success');
            }
        }

        function runFullCleanup() {
            clearOutput();
            log('ğŸ§¹ Running Full Therapist Data Cleanup...', 'success');
            
            log('Step 1: Checking for duplicates...', 'info');
            const duplicateCheck = checkForDuplicates();
            
            if (duplicateCheck && duplicateCheck.duplicatesFound) {
                log('\nStep 2: Removing duplicates...', 'info');
                removeDuplicates();
                
                log('\nStep 3: Validating one-card policy...', 'info');
                validateOneCardPolicy();
            } else {
                log('\nStep 2: No duplicates found, skipping removal', 'success');
            }
            
            log('\nStep 4: Testing performance...', 'info');
            testDataFetchPerformance();
            
            log('\nStep 5: Verifying Appwrite sync readiness...', 'info');
            verifyAppwriteSync();
            
            log('\nğŸ‰ Full cleanup complete!', 'success');
            log('Benefits achieved:', 'info');
            log('â€¢ Enforced one-card-per-therapist policy', 'info');
            log('â€¢ Optimized data fetching performance', 'info');
            log('â€¢ Prepared data for clean Appwrite sync', 'info');
            log('â€¢ Eliminated potential confusion from duplicates', 'info');
        }

        function generateDuplicateReport() {
            clearOutput();
            log('ğŸ“ Generating Comprehensive Duplicate Report...', 'info');
            
            const therapists = JSON.parse(localStorage.getItem('app_therapists') || '[]');
            
            if (therapists.length === 0) {
                log('âŒ No data to generate report from', 'error');
                return;
            }
            
            log('THERAPIST DUPLICATE ANALYSIS REPORT', 'info');
            log('=' .repeat(50), 'info');
            log(`Generated: ${new Date().toLocaleString()}`, 'info');
            log(`Total Records: ${therapists.length}`, 'info');
            
            // Detailed analysis
            const analysis = {
                byName: {},
                byEmail: {},
                byWhatsApp: {},
                byUserId: {},
                issues: []
            };
            
            therapists.forEach((t, index) => {
                const name = t.name?.toLowerCase().trim() || 'unnamed';
                const email = t.email?.toLowerCase() || 'no_email';
                const whatsapp = t.whatsappNumber || 'no_whatsapp';
                const userId = t.userId || t.$id || 'no_id';
                
                // Track all occurrences
                if (!analysis.byName[name]) analysis.byName[name] = [];
                analysis.byName[name].push({name: t.name, id: t.$id, live: t.isLive});
                
                if (!analysis.byEmail[email]) analysis.byEmail[email] = [];
                analysis.byEmail[email].push({name: t.name, id: t.$id, live: t.isLive});
                
                if (!analysis.byWhatsApp[whatsapp]) analysis.byWhatsApp[whatsapp] = [];
                analysis.byWhatsApp[whatsapp].push({name: t.name, id: t.$id, live: t.isLive});
                
                if (!analysis.byUserId[userId]) analysis.byUserId[userId] = [];
                analysis.byUserId[userId].push({name: t.name, id: t.$id, live: t.isLive});
            });
            
            // Report duplicates
            let totalDuplicates = 0;
            
            log('\nğŸ” DUPLICATE ANALYSIS:', 'info');
            
            ['byName', 'byEmail', 'byWhatsApp', 'byUserId'].forEach(category => {
                const categoryName = category.replace('by', '').toLowerCase();
                log(`\n${categoryName.toUpperCase()} DUPLICATES:`, 'info');
                
                let categoryDuplicates = 0;
                Object.entries(analysis[category]).forEach(([key, records]) => {
                    if (records.length > 1 && !key.includes('unnamed') && !key.includes('no_')) {
                        log(`âš ï¸ "${key}": ${records.length} records`, 'warning');
                        records.forEach(r => log(`   - ${r.name} (${r.id}) Live: ${r.live}`, 'info'));
                        categoryDuplicates += records.length - 1;
                    }
                });
                
                if (categoryDuplicates === 0) {
                    log(`âœ… No ${categoryName} duplicates found`, 'success');
                } else {
                    log(`ğŸš¨ ${categoryDuplicates} ${categoryName} duplicates detected`, 'error');
                    totalDuplicates += categoryDuplicates;
                }
            });
            
            log('\nğŸ“Š SUMMARY:', 'info');
            log(`Total duplicate entries: ${totalDuplicates}`, totalDuplicates > 0 ? 'warning' : 'success');
            log(`Data integrity: ${totalDuplicates === 0 ? 'GOOD' : 'NEEDS ATTENTION'}`, totalDuplicates === 0 ? 'success' : 'warning');
            
            if (totalDuplicates > 0) {
                log('\nğŸ› ï¸ RECOMMENDED ACTIONS:', 'warning');
                log('1. Run "Remove Duplicates" to clean up data', 'info');
                log('2. Enforce one-card policy for current user', 'info');
                log('3. Verify Appwrite sync after cleanup', 'info');
                log('4. Test data fetching performance', 'info');
            } else {
                log('\nâœ… NO ACTION REQUIRED - Data is clean', 'success');
            }
            
            return analysis;
        }

        function resetTherapistData() {
            if (!confirm('âš ï¸ This will delete ALL therapist data. Continue?')) {
                return;
            }
            
            clearOutput();
            log('ğŸ”„ Resetting All Therapist Data...', 'warning');
            
            localStorage.removeItem('app_therapists');
            localStorage.removeItem('debug_therapist_load');
            
            log('âœ… All therapist data cleared', 'success');
            log('The app will need to fetch fresh data from Appwrite', 'info');
        }

        function optimizeForFetching() {
            clearOutput();
            log('ğŸš€ Optimizing Data for Fetching Performance...', 'success');
            
            let therapists = JSON.parse(localStorage.getItem('app_therapists') || '[]');
            
            if (therapists.length === 0) {
                log('âŒ No data to optimize', 'error');
                return;
            }
            
            const originalCount = therapists.length;
            log(`Original dataset: ${originalCount} therapists`, 'info');
            
            // Remove duplicates
            removeDuplicates();
            
            // Reload after cleanup
            therapists = JSON.parse(localStorage.getItem('app_therapists') || '[]');
            
            // Optimize data structure
            const optimizedTherapists = therapists.map(therapist => {
                const optimized = { ...therapist };
                
                // Clean up empty or null fields
                Object.keys(optimized).forEach(key => {
                    if (optimized[key] === null || optimized[key] === undefined || optimized[key] === '') {
                        delete optimized[key];
                    }
                });
                
                // Ensure consistent data types
                if (optimized.isLive !== true && optimized.isLive !== false) {
                    optimized.isLive = false;
                }
                
                if (optimized.yearsOfExperience && typeof optimized.yearsOfExperience === 'string') {
                    optimized.yearsOfExperience = parseInt(optimized.yearsOfExperience) || 0;
                }
                
                // Optimize arrays
                if (optimized.massageTypes && Array.isArray(optimized.massageTypes)) {
                    optimized.massageTypes = [...new Set(optimized.massageTypes)]; // Remove duplicates
                }
                
                if (optimized.languages && Array.isArray(optimized.languages)) {
                    optimized.languages = [...new Set(optimized.languages)]; // Remove duplicates
                }
                
                return optimized;
            });
            
            localStorage.setItem('app_therapists', JSON.stringify(optimizedTherapists));
            
            log(`âœ… Optimization complete!`, 'success');
            log(`Optimized dataset: ${optimizedTherapists.length} therapists`, 'info');
            log(`Improvement: ${originalCount - optimizedTherapists.length} entries removed`, 'success');
            
            // Test performance improvement
            testDataFetchPerformance();
        }

        // Auto-run basic check on page load
        window.onload = function() {
            setTimeout(() => {
                log('ğŸ” Therapist Card Duplicate Checker Ready', 'success');
                log('Run "Check for Duplicates" to analyze your data', 'info');
            }, 500);
        };
    </script>
</body>
</html>