/**
 * ============================================================================
 * ðŸ”„ CHAT TYPES - STEP 15 CORE EXTRACTION
 * ============================================================================
 * 
 * PURPOSE: Define exact types for chat message operations
 * 
 * RULES:
 * - Clear success vs error states
 * - No ambiguous return types
 * - Deterministic error messages
 * - Testable in isolation
 * - NO booking creation logic
 * 
 * ============================================================================
 */

import { ValidationError } from './chat.contract';

// MESSAGE SEND SUCCESS RESPONSE
export interface MessageSendSuccess {
  success: true;
  messageId: string;
  message: string;
  timestamp: Date;
  data: {
    content: string;
    senderId: string;
    senderType: 'customer' | 'therapist' | 'admin' | 'system';
    messageType: 'text' | 'booking_request' | 'booking_update' | 'system_notification' | 'image';
    chatSessionId: string;
    status: 'sent' | 'delivered' | 'read';
    serverTimestamp: string;
  };
}

// MESSAGE ERROR TYPES
export type MessageErrorType = 
  | 'VALIDATION_FAILED'
  | 'APPWRITE_ERROR' 
  | 'NETWORK_ERROR'
  | 'UNKNOWN_ERROR'
  | 'CONTRACT_VIOLATION'
  | 'PERMISSION_DENIED'
  | 'SESSION_NOT_FOUND'
  | 'RATE_LIMIT_EXCEEDED'
  | 'CONTENT_BLOCKED';

export interface MessageSendError {
  success: false;
  errorType: MessageErrorType;
  message: string;
  timestamp: Date;
  details?: {
    validationErrors?: ValidationError[];
    appwriteError?: {
      code: number;
      message: string;
      type: string;
    };
    networkError?: {
      status?: number;
      message: string;
    };
    rateLimit?: {
      limit: number;
      remaining: number;
      resetTime: Date;
    };
    originalError?: unknown;
  };
}

// UNION TYPE FOR SEND MESSAGE RESULT
export type MessageSendResult = MessageSendSuccess | MessageSendError;

// APPWRITE MESSAGE DOCUMENT INTERFACE (matches Appwrite collection structure)
export interface MessageDocument {
  $id?: string;
  $collectionId?: string;
  $databaseId?: string;
  $createdAt?: string;
  $updatedAt?: string;
  $permissions?: string[];
  
  // Message core fields
  content: string;
  senderId: string;
  senderType: 'customer' | 'therapist' | 'admin' | 'system';
  messageType: 'text' | 'booking_request' | 'booking_update' | 'system_notification' | 'image';
  chatSessionId: string;
  
  // Optional message fields
  replyToId?: string;
  metadata?: {
    bookingId?: string;
    imageUrl?: string;
    location?: {
      lat: number;
      lng: number;
      address: string;
    };
    urgency?: 'low' | 'normal' | 'high';
    autoGenerated?: boolean;
    systemContext?: string;
  };
  tempId?: string;
  
  // System fields
  status: 'sent' | 'delivered' | 'read' | 'failed';
  serverTimestamp: string;
  clientTimestamp?: string;
  readByRecipients?: string[]; // Array of user IDs who read the message
  deliveredToRecipients?: string[]; // Array of user IDs who received the message
  editHistory?: {
    editedAt: string;
    previousContent: string;
    editedBy: string;
  }[];
  
  // Moderation fields
  flagged?: boolean;
  flagReason?: string;
  moderatedBy?: string;
  moderatedAt?: string;
}

// CHAT SESSION INTERFACE
export interface ChatSession {
  $id?: string;
  sessionId: string;
  participants: {
    customerId?: string;
    therapistId?: string;
    adminIds?: string[];
  };
  status: 'active' | 'ended' | 'paused' | 'archived';
  createdAt: string;
  lastActivity: string;
  messageCount: number;
  bookingId?: string; // Optional linkage to booking (but no auto-creation)
  metadata?: {
    customerName?: string;
    therapistName?: string;
    serviceType?: string;
    location?: string;
  };
}

// TYPE GUARDS
export function isMessageSuccess(result: MessageSendResult): result is MessageSendSuccess {
  return result.success === true;
}

export function isMessageError(result: MessageSendResult): result is MessageSendError {
  return result.success === false;
}

// ERROR FACTORY FUNCTIONS
export function createValidationError(
  validationErrors: ValidationError[]
): MessageSendError {
  return {
    success: false,
    errorType: 'VALIDATION_FAILED',
    message: `Message validation failed: ${validationErrors.map(e => e.message).join(', ')}`,
    timestamp: new Date(),
    details: {
      validationErrors
    }
  };
}

export function createAppwriteError(
  appwriteError: any
): MessageSendError {
  return {
    success: false,
    errorType: 'APPWRITE_ERROR',
    message: appwriteError?.message || 'Message storage failed',
    timestamp: new Date(),
    details: {
      appwriteError: {
        code: appwriteError?.code || 0,
        message: appwriteError?.message || 'Unknown Appwrite error',
        type: appwriteError?.type || 'unknown'
      },
      originalError: appwriteError
    }
  };
}

export function createNetworkError(
  error: any,
  status?: number
): MessageSendError {
  return {
    success: false,
    errorType: 'NETWORK_ERROR',
    message: 'Message send failed due to network error',
    timestamp: new Date(),
    details: {
      networkError: {
        status,
        message: error?.message || 'Network request failed'
      },
      originalError: error
    }
  };
}

export function createPermissionError(
  reason: string
): MessageSendError {
  return {
    success: false,
    errorType: 'PERMISSION_DENIED',
    message: `Permission denied: ${reason}`,
    timestamp: new Date()
  };
}

export function createSessionNotFoundError(
  sessionId: string
): MessageSendError {
  return {
    success: false,
    errorType: 'SESSION_NOT_FOUND',
    message: `Chat session not found: ${sessionId}`,
    timestamp: new Date()
  };
}

export function createRateLimitError(
  limit: number,
  resetTime: Date
): MessageSendError {
  return {
    success: false,
    errorType: 'RATE_LIMIT_EXCEEDED',
    message: `Message rate limit exceeded. Try again after ${resetTime.toISOString()}`,
    timestamp: new Date(),
    details: {
      rateLimit: {
        limit,
        remaining: 0,
        resetTime
      }
    }
  };
}

export function createContentBlockedError(
  reason: string
): MessageSendError {
  return {
    success: false,
    errorType: 'CONTENT_BLOCKED',
    message: `Message content blocked: ${reason}`,
    timestamp: new Date()
  };
}

export function createUnknownError(
  error: any
): MessageSendError {
  return {
    success: false,
    errorType: 'UNKNOWN_ERROR',
    message: error?.message || 'An unexpected error occurred while sending message',
    timestamp: new Date(),
    details: {
      originalError: error
    }
  };
}

export function createContractViolationError(
  message: string
): MessageSendError {
  return {
    success: false,
    errorType: 'CONTRACT_VIOLATION',
    message: `Chat contract violation: ${message}`,
    timestamp: new Date()
  };
}

// SUCCESS FACTORY FUNCTION
export function createMessageSuccess(
  messageId: string,
  messageData: MessageDocument
): MessageSendSuccess {
  return {
    success: true,
    messageId,
    message: 'Message sent successfully',
    timestamp: new Date(),
    data: {
      content: messageData.content,
      senderId: messageData.senderId,
      senderType: messageData.senderType,
      messageType: messageData.messageType,
      chatSessionId: messageData.chatSessionId,
      status: messageData.status as 'sent' | 'delivered' | 'read',
      serverTimestamp: messageData.serverTimestamp
    }
  };
}

// RATE LIMITING HELPERS
export interface RateLimit {
  identifier: string; // senderId or IP
  windowStart: Date;
  requestCount: number;
  limit: number;
  windowDuration: number; // milliseconds
}

export function checkRateLimit(
  rateLimits: Map<string, RateLimit>,
  identifier: string,
  limit: number = 100,
  windowDuration: number = 60 * 60 * 1000 // 1 hour
): { allowed: boolean; remaining: number; resetTime: Date } {
  const now = new Date();
  const existing = rateLimits.get(identifier);

  if (!existing || now.getTime() - existing.windowStart.getTime() >= windowDuration) {
    // New window or reset
    rateLimits.set(identifier, {
      identifier,
      windowStart: now,
      requestCount: 1,
      limit,
      windowDuration
    });
    
    return {
      allowed: true,
      remaining: limit - 1,
      resetTime: new Date(now.getTime() + windowDuration)
    };
  }

  if (existing.requestCount >= limit) {
    // Rate limit exceeded
    return {
      allowed: false,
      remaining: 0,
      resetTime: new Date(existing.windowStart.getTime() + windowDuration)
    };
  }

  // Update count
  existing.requestCount++;
  
  return {
    allowed: true,
    remaining: limit - existing.requestCount,
    resetTime: new Date(existing.windowStart.getTime() + windowDuration)
  };
}