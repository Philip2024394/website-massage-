/**
 * ============================================================================
 * ðŸ’¬ CHAT CONTRACT - STEP 15 CORE EXTRACTION
 * ============================================================================
 * 
 * MANDATORY: This contract defines the exact shape of chat message data.
 * 
 * PURPOSE:
 * - Validates message payload before any Appwrite operations
 * - Fails early if data doesn't match requirements
 * - Stops AI + UI from sending garbage messages
 * - Enforces consistent message structure
 * - Prevents chat/booking entanglement
 * 
 * RULES:
 * - If data doesn't match â†’ fail early
 * - No exceptions or "helpful" modifications
 * - Deterministic validation only
 * - NO booking creation logic here
 * 
 * ============================================================================
 */

// REQUIRED FIELDS - Must be present
export interface ChatContractRequired {
  content: string;
  senderId: string;
  senderType: 'customer' | 'therapist' | 'admin' | 'system';
  messageType: 'text' | 'booking_request' | 'booking_update' | 'system_notification' | 'image';
  chatSessionId: string;
}

// OPTIONAL FIELDS - May be present
export interface ChatContractOptional {
  replyToId?: string;
  metadata?: {
    bookingId?: string;
    imageUrl?: string;
    location?: {
      lat: number;
      lng: number;
      address: string;
    };
    urgency?: 'low' | 'normal' | 'high';
    autoGenerated?: boolean;
    systemContext?: string;
  };
  clientTimestamp?: Date;
  tempId?: string; // For UI optimistic updates
  retryCount?: number; // For UI retry tracking only
}

// COMPLETE CHAT CONTRACT
export interface ChatContract extends ChatContractRequired, ChatContractOptional {}

// SENDER IDENTITY RULES
export interface SenderIdentityRules {
  customerId?: string;
  therapistId?: string;
  adminId?: string;
  isVerified: boolean;
  permissions: ('send' | 'edit' | 'delete' | 'moderate')[];
}

// MESSAGE SIZE AND TYPE LIMITS
export const MESSAGE_LIMITS = {
  content: {
    minLength: 1,
    maxLength: 2000, // Characters
    maxLines: 50
  },
  image: {
    maxSize: 5 * 1024 * 1024, // 5MB
    allowedTypes: ['image/jpeg', 'image/png', 'image/webp'],
    maxWidth: 1920,
    maxHeight: 1080
  },
  session: {
    maxMessagesPerHour: 100,
    maxMessagesPerDay: 500
  }
} as const;

// VALIDATION ERROR TYPES
export interface ValidationError {
  field: string;
  message: string;
  expected: string;
  received: any;
  code: string;
}

// CONTRACT VALIDATION RESULT
export interface ContractValidationResult {
  valid: boolean;
  errors: ValidationError[];
  sanitizedData?: ChatContract;
}

/**
 * MANDATORY CONTRACT VALIDATOR
 * 
 * This function enforces the exact message payload shape.
 * If validation fails, message sending fails immediately.
 * 
 * NO EXCEPTIONS. NO "HELPFUL" MODIFICATIONS.
 * NO BOOKING CREATION LOGIC.
 */
export function validateChatContract(payload: unknown): ContractValidationResult {
  const errors: ValidationError[] = [];

  // Type guard
  if (!payload || typeof payload !== 'object') {
    return {
      valid: false,
      errors: [{
        field: 'root',
        message: 'Payload must be an object',
        expected: 'object',
        received: typeof payload,
        code: 'INVALID_PAYLOAD_TYPE'
      }]
    };
  }

  const data = payload as Record<string, any>;

  // REQUIRED FIELD VALIDATION
  const requiredValidations: Array<{
    field: keyof ChatContractRequired;
    validator: (value: any) => { valid: boolean; message?: string; expected: string; code: string; };
  }> = [
    {
      field: 'content',
      validator: (value) => {
        if (typeof value !== 'string') {
          return {
            valid: false,
            message: 'Content must be a string',
            expected: 'string',
            code: 'CONTENT_NOT_STRING'
          };
        }
        
        const trimmed = value.trim();
        if (trimmed.length < MESSAGE_LIMITS.content.minLength) {
          return {
            valid: false,
            message: `Content must be at least ${MESSAGE_LIMITS.content.minLength} character(s)`,
            expected: `string (min ${MESSAGE_LIMITS.content.minLength} chars)`,
            code: 'CONTENT_TOO_SHORT'
          };
        }
        
        if (trimmed.length > MESSAGE_LIMITS.content.maxLength) {
          return {
            valid: false,
            message: `Content exceeds maximum length of ${MESSAGE_LIMITS.content.maxLength} characters`,
            expected: `string (max ${MESSAGE_LIMITS.content.maxLength} chars)`,
            code: 'CONTENT_TOO_LONG'
          };
        }
        
        const lineCount = trimmed.split('\n').length;
        if (lineCount > MESSAGE_LIMITS.content.maxLines) {
          return {
            valid: false,
            message: `Content exceeds maximum of ${MESSAGE_LIMITS.content.maxLines} lines`,
            expected: `string (max ${MESSAGE_LIMITS.content.maxLines} lines)`,
            code: 'CONTENT_TOO_MANY_LINES'
          };
        }
        
        return {
          valid: true,
          expected: 'string (valid length and lines)',
          code: 'VALID'
        };
      }
    },
    {
      field: 'senderId',
      validator: (value) => ({
        valid: typeof value === 'string' && value.trim().length >= 3,
        message: 'Sender ID must be a string with at least 3 characters',
        expected: 'string (min 3 chars)',
        code: typeof value !== 'string' ? 'SENDER_ID_NOT_STRING' : 'SENDER_ID_TOO_SHORT'
      })
    },
    {
      field: 'senderType',
      validator: (value) => ({
        valid: ['customer', 'therapist', 'admin', 'system'].includes(value),
        message: 'Sender type must be one of: customer, therapist, admin, system',
        expected: "'customer' | 'therapist' | 'admin' | 'system'",
        code: 'INVALID_SENDER_TYPE'
      })
    },
    {
      field: 'messageType',
      validator: (value) => ({
        valid: ['text', 'booking_request', 'booking_update', 'system_notification', 'image'].includes(value),
        message: 'Message type must be one of: text, booking_request, booking_update, system_notification, image',
        expected: "'text' | 'booking_request' | 'booking_update' | 'system_notification' | 'image'",
        code: 'INVALID_MESSAGE_TYPE'
      })
    },
    {
      field: 'chatSessionId',
      validator: (value) => ({
        valid: typeof value === 'string' && value.trim().length >= 10,
        message: 'Chat session ID must be a string with at least 10 characters',
        expected: 'string (min 10 chars)',
        code: typeof value !== 'string' ? 'SESSION_ID_NOT_STRING' : 'SESSION_ID_TOO_SHORT'
      })
    }
  ];

  // Execute required validations
  for (const { field, validator } of requiredValidations) {
    const result = validator(data[field]);
    if (!result.valid) {
      errors.push({
        field,
        message: result.message || 'Invalid value',
        expected: result.expected,
        received: data[field],
        code: result.code
      });
    }
  }

  // OPTIONAL FIELD VALIDATION (only if present)
  if (data.replyToId && (typeof data.replyToId !== 'string' || data.replyToId.trim().length < 10)) {
    errors.push({
      field: 'replyToId',
      message: 'Reply to ID must be a string with at least 10 characters if provided',
      expected: 'string (min 10 chars) | undefined',
      received: data.replyToId,
      code: 'INVALID_REPLY_TO_ID'
    });
  }

  if (data.tempId && typeof data.tempId !== 'string') {
    errors.push({
      field: 'tempId',
      message: 'Temp ID must be a string if provided',
      expected: 'string | undefined',
      received: data.tempId,
      code: 'INVALID_TEMP_ID'
    });
  }

  if (data.clientTimestamp && !(data.clientTimestamp instanceof Date)) {
    errors.push({
      field: 'clientTimestamp',
      message: 'Client timestamp must be a Date object if provided',
      expected: 'Date | undefined',
      received: data.clientTimestamp,
      code: 'INVALID_CLIENT_TIMESTAMP'
    });
  }

  if (data.retryCount !== undefined && (!Number.isInteger(data.retryCount) || data.retryCount < 0)) {
    errors.push({
      field: 'retryCount',
      message: 'Retry count must be a non-negative integer if provided',
      expected: 'number (integer >= 0) | undefined',
      received: data.retryCount,
      code: 'INVALID_RETRY_COUNT'
    });
  }

  // METADATA VALIDATION (if present)
  if (data.metadata) {
    if (typeof data.metadata !== 'object') {
      errors.push({
        field: 'metadata',
        message: 'Metadata must be an object if provided',
        expected: 'object | undefined',
        received: data.metadata,
        code: 'INVALID_METADATA_TYPE'
      });
    } else {
      const metadata = data.metadata;
      
      // Validate location if present
      if (metadata.location) {
        if (typeof metadata.location !== 'object' ||
            typeof metadata.location.lat !== 'number' ||
            typeof metadata.location.lng !== 'number' ||
            typeof metadata.location.address !== 'string' ||
            metadata.location.lat < -90 || metadata.location.lat > 90 ||
            metadata.location.lng < -180 || metadata.location.lng > 180) {
          errors.push({
            field: 'metadata.location',
            message: 'Invalid location format',
            expected: '{ lat: number (-90 to 90), lng: number (-180 to 180), address: string }',
            received: metadata.location,
            code: 'INVALID_LOCATION'
          });
        }
      }
      
      // Validate urgency if present
      if (metadata.urgency && !['low', 'normal', 'high'].includes(metadata.urgency)) {
        errors.push({
          field: 'metadata.urgency',
          message: 'Invalid urgency level',
          expected: "'low' | 'normal' | 'high' | undefined",
          received: metadata.urgency,
          code: 'INVALID_URGENCY'
        });
      }
    }
  }

  // SPECIAL VALIDATION: Message type consistency
  if (data.messageType === 'image' && !data.metadata?.imageUrl) {
    errors.push({
      field: 'metadata.imageUrl',
      message: 'Image messages must include imageUrl in metadata',
      expected: 'string (image URL)',
      received: data.metadata?.imageUrl,
      code: 'MISSING_IMAGE_URL'
    });
  }

  if (data.messageType === 'booking_request' && !data.content.includes('booking')) {
    errors.push({
      field: 'content',
      message: 'Booking request messages should reference booking in content',
      expected: 'string containing "booking"',
      received: data.content,
      code: 'BOOKING_REQUEST_NO_BOOKING_REFERENCE'
    });
  }

  // Return validation result
  if (errors.length > 0) {
    return {
      valid: false,
      errors
    };
  }

  // Create sanitized data with only contract fields
  const sanitizedData: ChatContract = {
    // Required fields
    content: data.content.trim(),
    senderId: data.senderId.trim(),
    senderType: data.senderType,
    messageType: data.messageType,
    chatSessionId: data.chatSessionId.trim(),
    
    // Optional fields (only include if present)
    ...(data.replyToId && { replyToId: data.replyToId.trim() }),
    ...(data.metadata && { metadata: data.metadata }),
    ...(data.clientTimestamp && { clientTimestamp: data.clientTimestamp }),
    ...(data.tempId && { tempId: data.tempId }),
    ...(data.retryCount !== undefined && { retryCount: data.retryCount })
  };

  return {
    valid: true,
    errors: [],
    sanitizedData
  };
}

/**
 * TYPE GUARD: Check if data matches ChatContract
 */
export function isValidChatContract(data: unknown): data is ChatContract {
  const result = validateChatContract(data);
  return result.valid;
}

/**
 * SENDER IDENTITY VALIDATOR
 * 
 * Validates that the sender has permission to send messages
 */
export function validateSenderIdentity(
  senderId: string,
  senderType: ChatContract['senderType'],
  identity: SenderIdentityRules
): { valid: boolean; error?: string } {
  // Check if sender has permission to send messages
  if (!identity.permissions.includes('send')) {
    return {
      valid: false,
      error: 'Sender does not have permission to send messages'
    };
  }

  // Verify sender identity matches type
  switch (senderType) {
    case 'customer':
      if (!identity.customerId || identity.customerId !== senderId) {
        return {
          valid: false,
          error: 'Sender ID does not match customer identity'
        };
      }
      break;
    case 'therapist':
      if (!identity.therapistId || identity.therapistId !== senderId) {
        return {
          valid: false,
          error: 'Sender ID does not match therapist identity'
        };
      }
      break;
    case 'admin':
      if (!identity.adminId || identity.adminId !== senderId) {
        return {
          valid: false,
          error: 'Sender ID does not match admin identity'
        };
      }
      break;
    case 'system':
      // System messages require admin or special system permissions
      if (!identity.adminId && !identity.permissions.includes('moderate')) {
        return {
          valid: false,
          error: 'System messages require admin or moderator permissions'
        };
      }
      break;
  }

  return { valid: true };
}

export default {
  validateChatContract,
  isValidChatContract,
  validateSenderIdentity,
  MESSAGE_LIMITS
};